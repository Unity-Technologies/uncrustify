Line [Token]             Text
1    [QUALIFIER]         public
1    [CLASS]             class
1    [TYPE]              TestClass
1    [BRACE_OPEN]        {
1    [NEWLINE]           
2    [QUALIFIER]         private
2    [QUALIFIER]         static
2    [TYPE]              void
2    [FUNC_DEF]          initMap
2    [FPAREN_OPEN]       (
2    [TYPE]              void
2    [FPAREN_CLOSE]      )
2    [BRACE_OPEN]        {
2    [NEWLINE]           
3    [TYPE]              HashMap
3    [ANGLE_OPEN]        <
3    [TYPE]              String
3    [COMMA]             ,
3    [TYPE]              HashMap
3    [ANGLE_OPEN]        <
3    [TYPE]              String
3    [COMMA]             ,
3    [TYPE]              List
3    [ANGLE_OPEN]        <
3    [TYPE]              Track
3    [ANGLE_CLOSE]       >
3    [ANGLE_CLOSE]       >
3    [ANGLE_CLOSE]       >
3    [WORD]              resolutionTracks
3    [ASSIGN]            =
3    [NEW]               new
3    [FUNC_CALL]         HashMap
3    [ANGLE_OPEN]        <
3    [TYPE]              String
3    [COMMA]             ,
3    [TYPE]              HashMap
3    [ANGLE_OPEN]        <
3    [TYPE]              String
3    [COMMA]             ,
3    [TYPE]              List
3    [ANGLE_OPEN]        <
3    [TYPE]              Track
3    [ANGLE_CLOSE]       >
3    [ANGLE_CLOSE]       >
3    [ANGLE_CLOSE]       >
3    [FPAREN_OPEN]       (
3    [FPAREN_CLOSE]      )
3    [SEMICOLON]         ;
3    [NEWLINE]           
4    [BRACE_CLOSE]       }
4    [NEWLINE]           
6    [QUALIFIER]         private
6    [QUALIFIER]         static
6    [TYPE]              void
6    [FUNC_DEF]          addTrackToMap
6    [FPAREN_OPEN]       (
6    [TYPE]              String
6    [WORD]              resolution
6    [COMMA]             ,
6    [TYPE]              Track
6    [WORD]              track
6    [COMMA]             ,
6    [TYPE]              HashMap
6    [ANGLE_OPEN]        <
6    [TYPE]              String
6    [COMMA]             ,
6    [TYPE]              HashMap
6    [ANGLE_OPEN]        <
6    [TYPE]              String
6    [COMMA]             ,
6    [TYPE]              List
6    [ANGLE_OPEN]        <
6    [TYPE]              Track
6    [ANGLE_CLOSE]       >
6    [ANGLE_CLOSE]       >
6    [ANGLE_CLOSE]       >
6    [WORD]              resolutionTracks
6    [FPAREN_CLOSE]      )
6    [BRACE_OPEN]        {
6    [NEWLINE]           
7    [TYPE]              HashMap
7    [ANGLE_OPEN]        <
7    [TYPE]              String
7    [COMMA]             ,
7    [TYPE]              List
7    [ANGLE_OPEN]        <
7    [TYPE]              Track
7    [ANGLE_CLOSE]       >
7    [ANGLE_CLOSE]       >
7    [WORD]              tracks
7    [ASSIGN]            =
7    [WORD]              null
7    [SEMICOLON]         ;
7    [NEWLINE]           
9    [IF]                if
9    [SPAREN_OPEN]       (
9    [WORD]              resolutionTracks
9    [MEMBER]            .
9    [FUNC_CALL]         containsKey
9    [FPAREN_OPEN]       (
9    [WORD]              resolution
9    [FPAREN_CLOSE]      )
9    [SPAREN_CLOSE]      )
9    [BRACE_OPEN]        {
9    [NEWLINE]           
10   [WORD]              tracks
10   [ASSIGN]            =
10   [WORD]              resolutionTracks
10   [MEMBER]            .
10   [FUNC_CALL]         get
10   [FPAREN_OPEN]       (
10   [WORD]              resolution
10   [FPAREN_CLOSE]      )
10   [SEMICOLON]         ;
10   [NEWLINE]           
11   [BRACE_CLOSE]       }
11   [ELSE]              else
11   [BRACE_OPEN]        {
11   [NEWLINE]           
12   [WORD]              tracks
12   [ASSIGN]            =
12   [NEW]               new
12   [FUNC_CALL]         HashMap
12   [ANGLE_OPEN]        <
12   [TYPE]              String
12   [COMMA]             ,
12   [TYPE]              List
12   [ANGLE_OPEN]        <
12   [TYPE]              Track
12   [ANGLE_CLOSE]       >
12   [ANGLE_CLOSE]       >
12   [FPAREN_OPEN]       (
12   [FPAREN_CLOSE]      )
12   [SEMICOLON]         ;
12   [NEWLINE]           
13   [TYPE]              tracks
13   [MEMBER]            .
13   [FUNC_CALL]         put
13   [FPAREN_OPEN]       (
13   [STRING]            "soun"
13   [COMMA]             ,
13   [NEW]               new
13   [FUNC_CALL]         LinkedList
13   [ANGLE_OPEN]        <
13   [TYPE]              Track
13   [ANGLE_CLOSE]       >
13   [FPAREN_OPEN]       (
13   [FPAREN_CLOSE]      )
13   [FPAREN_CLOSE]      )
13   [SEMICOLON]         ;
13   [NEWLINE]           
14   [TYPE]              tracks
14   [MEMBER]            .
14   [FUNC_CALL]         put
14   [FPAREN_OPEN]       (
14   [STRING]            "vide"
14   [COMMA]             ,
14   [NEW]               new
14   [FUNC_CALL]         LinkedList
14   [ANGLE_OPEN]        <
14   [TYPE]              Track
14   [ANGLE_CLOSE]       >
14   [FPAREN_OPEN]       (
14   [FPAREN_CLOSE]      )
14   [FPAREN_CLOSE]      )
14   [SEMICOLON]         ;
14   [NEWLINE]           
15   [TYPE]              resolutionTracks
15   [MEMBER]            .
15   [FUNC_CALL]         put
15   [FPAREN_OPEN]       (
15   [WORD]              resolution
15   [COMMA]             ,
15   [WORD]              tracks
15   [FPAREN_CLOSE]      )
15   [SEMICOLON]         ;
15   [NEWLINE]           
16   [BRACE_CLOSE]       }
16   [NEWLINE]           
18   [IF]                if
18   [SPAREN_OPEN]       (
18   [WORD]              track
18   [MEMBER]            .
18   [FUNC_CALL]         getHandler
18   [FPAREN_OPEN]       (
18   [FPAREN_CLOSE]      )
18   [COMPARE]           !=
18   [WORD]              null
18   [SPAREN_CLOSE]      )
18   [BRACE_OPEN]        {
18   [NEWLINE]           
19   [IF]                if
19   [SPAREN_OPEN]       (
19   [WORD]              track
19   [MEMBER]            .
19   [FUNC_CALL]         getHandler
19   [FPAREN_OPEN]       (
19   [FPAREN_CLOSE]      )
19   [MEMBER]            .
19   [FUNC_CALL]         equals
19   [FPAREN_OPEN]       (
19   [STRING]            "soun"
19   [FPAREN_CLOSE]      )
19   [SPAREN_CLOSE]      )
19   [BRACE_OPEN]        {
19   [NEWLINE]           
20   [TYPE]              List
20   [ANGLE_OPEN]        <
20   [TYPE]              Track
20   [ANGLE_CLOSE]       >
20   [WORD]              audioTracks
20   [ASSIGN]            =
20   [WORD]              tracks
20   [MEMBER]            .
20   [FUNC_CALL]         get
20   [FPAREN_OPEN]       (
20   [STRING]            "soun"
20   [FPAREN_CLOSE]      )
20   [SEMICOLON]         ;
20   [NEWLINE]           
21   [TYPE]              audioTracks
21   [MEMBER]            .
21   [FUNC_CALL]         add
21   [FPAREN_OPEN]       (
21   [WORD]              track
21   [FPAREN_CLOSE]      )
21   [SEMICOLON]         ;
21   [NEWLINE]           
22   [BRACE_CLOSE]       }
22   [ELSE]              else
22   [ELSEIF]            if
22   [SPAREN_OPEN]       (
22   [WORD]              track
22   [MEMBER]            .
22   [FUNC_CALL]         getHandler
22   [FPAREN_OPEN]       (
22   [FPAREN_CLOSE]      )
22   [MEMBER]            .
22   [FUNC_CALL]         equals
22   [FPAREN_OPEN]       (
22   [STRING]            "vide"
22   [FPAREN_CLOSE]      )
22   [SPAREN_CLOSE]      )
22   [BRACE_OPEN]        {
22   [NEWLINE]           
23   [TYPE]              List
23   [ANGLE_OPEN]        <
23   [TYPE]              Track
23   [ANGLE_CLOSE]       >
23   [WORD]              videoTracks
23   [ASSIGN]            =
23   [WORD]              tracks
23   [MEMBER]            .
23   [FUNC_CALL]         get
23   [FPAREN_OPEN]       (
23   [STRING]            "vide"
23   [FPAREN_CLOSE]      )
23   [SEMICOLON]         ;
23   [NEWLINE]           
24   [TYPE]              videoTracks
24   [MEMBER]            .
24   [FUNC_CALL]         add
24   [FPAREN_OPEN]       (
24   [WORD]              track
24   [FPAREN_CLOSE]      )
24   [SEMICOLON]         ;
24   [NEWLINE]           
25   [BRACE_CLOSE]       }
25   [NEWLINE]           
26   [BRACE_CLOSE]       }
26   [NEWLINE]           
27   [BRACE_CLOSE]       }
27   [NEWLINE]           
28   [BRACE_CLOSE]       }
28   [NEWLINE]           